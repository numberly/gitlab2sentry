import logging
import os
from collections import Counter, defaultdict
from datetime import datetime, timedelta

import requests
import sentry_sdk
from gitlab import Gitlab
from gitlab.exceptions import GitlabGetError
from gitlab.const import MAINTAINER_ACCESS, OWNER_ACCESS
from slugify import slugify

GITLAB_URL = os.getenv("GITLAB_URL", "https://gitlab.numberly.in")
GITLAB_TOKEN = os.getenv("GITLAB_TOKEN")
SENTRY_URL = os.getenv("SENTRY_URL", "https://sentry.numberly.net")
SENTRY_TOKEN = os.getenv("SENTRY_TOKEN")

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(name)s %(levelname)s: %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
)


class Sentry:
    def __init__(self, url, *args, **kwargs):
        self.url = url
        self.token = kwargs["auth_token"]
        self.org_slug = kwargs["org_slug"]
        self.headers = {"Authorization": f"Bearer {self.token}"}

    def get_projects(self):
        next = None
        url = f"{self.url}/api/0/projects/"
        while True:
            r = requests.get(
                url,
                headers=self.headers,
            )
            yield r.json()
            if r.links["next"]["results"] == "true":
                url = r.links["next"]["url"]
            else:
                break

    def create_or_get_team(self, team):
        team_slug = slugify(team)
        data = {
            "name": team,
            "slug": team_slug,
        }
        r = requests.post(
            f"{self.url}/api/0/organizations/{self.org_slug}/teams/",
            headers=self.headers,
            data=data,
        )
        result = r.json()
        if r.status_code != 201:
            if r.status_code == 409:
                r = requests.get(
                    f"{self.url}/api/0/teams/{self.org_slug}/{team_slug}/",
                    headers=self.headers,
                )
                return r.json()
            return None

        logging.info(f"team {team} created!")
        return result

    def get_project(self, team, project_slug):
        r = requests.get(
            f"{self.url}/api/0/projects/{self.org_slug}/{project_slug}/",
            headers=self.headers,
        )
        if r.status_code != 200:
            return None
        return r.json()

    def create_or_get_project(self, team, project):
        project_slug = slugify(project).lower()
        data = {
            "name": project,
            "slug": project_slug,
        }
        r = requests.post(
            f"{self.url}/api/0/teams/{self.org_slug}/{team}/projects/",
            headers=self.headers,
            data=data,
        )
        result = r.json()
        if r.status_code != 201:
            if r.status_code == 409:
                return self.get_project(team, project_slug)
            raise Exception(result)

        return result

    def get_clients_keys(self, team, project):
        r = requests.get(
            f"{self.url}/api/0/projects/{self.org_slug}/{project}/keys/",
            headers=self.headers,
        )
        if r.status_code != 200:
            return None
        return r.json()

    def set_rate_limit_for_key(self, project, key):
        data = {"rateLimit": {"window": 60, "count": 300}}
        url = f"{self.url}/api/0/projects/{self.org_slug}/{project}/keys/{key}/"
        r = requests.put(
            f"{self.url}/api/0/projects/{self.org_slug}/{project}/keys/{key}/",
            headers=self.headers,
            json=data,
        )
        if r.status_code != 200:
            return None
        return r.json()


def create_mr(project, branch_name, file_path, content, title, description):
    try:
        project.branches.get(branch_name)
        logging.info("branch already exists, deleting")
        project.branches.delete(branch_name)
    except Exception:
        pass

    project.branches.create({"branch": branch_name, "ref": project.default_branch})
    try:
        f = project.files.get(file_path=file_path, ref=project.default_branch)
        f.content = content
        f.save(branch=branch_name, commit_message="Udpate .sentryclirc")
    except Exception:
        f = project.files.create(
            {
                "author_email": "gitlab2sentry@numberly.com",
                "author_name": "gitlab2sentry",
                "branch": branch_name,
                "commit_message": "Update .sentryclirc",
                "content": f"{content}",
                "file_path": file_path,
            }
        )
    project.mergerequests.create(
        {
            "description": description,
            "remove_source_branch": True,
            "source_branch": branch_name,
            "target_branch": project.default_branch,
            "title": title,
        }
    )


def ensure_sentry_team(team_name, sentry):
    logging.info(f"ensuring team {team_name} exists on sentry")
    sentry.create_or_get_team(team_name)


def propose_sentry_mr(project, contacts):
    content = """## File generated by gitlab2sentry
[defaults]
url = https://sentry.numberly.net/
"""
    mentions = ' '.join(['@{}'.format(x) for x in contacts])
    msg = (
        f"{mentions} Merge this and it will automatically create a Sentry project "
        f"for {project.name_with_namespace} :cookie:"
    )
    create_mr(
        project,
        "auto_add_sentry",
        ".sentryclirc",
        content,
        f"[gitlab2sentry] Merge me to add sentry to {project.name} or close me",
        msg,
    )


def add_sentry_dsn_mr(project, dsn, contacts):
    content = f"""## File generated by gitlab2sentry
[defaults]
url = https://sentry.numberly.net/
dsn = {dsn}
"""
    mentions = ' '.join(['@{}'.format(x) for x in contacts])
    msg = (
        f"{mentions} Congrats, your Sentry project has been created, merge this "
        "to finalize your Sentry integration :clap: :cookie:"
    )
    create_mr(
        project,
        "auto_add_sentry_dsn",
        ".sentryclirc",
        content,
        f"[gitlab2sentry] Merge me to add your sentry DSN to {project.name}",
        msg,
    )


def get_sentryclirc(project):
    has_file, has_dsn = False, False
    try:
        f = project.files.get(file_path=".sentryclirc", ref=project.default_branch)
    except GitlabGetError:
        pass
    else:
        has_file = True
        for line in f.decode().splitlines():
            if line.startswith(b"dsn"):
                has_dsn = True
    return has_file, has_dsn


def main():
    # connect to gitlab & sentry
    gitlab = Gitlab(GITLAB_URL, private_token=GITLAB_TOKEN)
    gitlab.auth()
    sentry = Sentry(SENTRY_URL, auth_token=SENTRY_TOKEN, org_slug="numberly")

    # prepare our run variables
    mr_by_project = defaultdict(list)
    mr_counts = Counter()
    run_stats = Counter()
    yesterday = datetime.utcnow() - timedelta(hours=24)

    # get all the MRs we ever done
    for mr in gitlab.mergerequests.list(as_list=False, state="all", scope="created_by_me"):
        if "sentry" in mr.title.lower():
            mr_counts[mr.project_id] += 1
            mr_by_project[mr.project_id].append(mr)

    # Get user id of all active users
    users = gitlab.users.list(as_list=False, active=True)
    users_id = [x.id for x in users if x.bot == False]

    # loop for all team gitlab groups
    sentry_groups = set()
    groups = gitlab.groups.list(as_list=False, include_subgroups=True)
    for group in groups:
        # only get contacts with owner/maintainers access for mention in the MR
        # would be nice to ping all maintainers via https://gitlab.com/gitlab-org/gitlab/-/issues/282438
        contacts = [
            x for x in group.members_all.list(all=True) if \
            x.access_level == OWNER_ACCESS or \
            x.access_level == MAINTAINER_ACCESS and \
            x.id in users_id
        ]

        # we are only interested in team groups
        if not group.full_name.startswith("team-"):
            continue
        sentry_group_name = group.full_name.split("/")[0].strip()

        # ensure each gitlab group has a sentry sibling
        logging.debug(f"handling gitlab group {group.full_name}")
        if sentry_group_name not in sentry_groups:
            ensure_sentry_team(sentry_group_name, sentry)
            sentry_groups.add(sentry_group_name)

        # check every project of the group
        for project in group.projects.list(as_list=False, archived=False):
            # skip project if MRs are disabled
            if not project.merge_requests_enabled:
                logging.info(
                    f"project {project.name_with_namespace} does not accept MRs"
                )
                run_stats["mr_disabled"] += 1
                continue

            # # we will only run on projects which changed within 24H
            # if (
            #     datetime.fromisoformat(project.last_activity_at.replace("Z", ""))
            #     < yesterday
            # ):
            #     logging.info(
            #         f"project {project.name_with_namespace} skipped due to last"
            #         f" activity being {project.last_activity_at}"
            #     )
            #     continue

            # check sentryclirc presence and dsn in the file
            project = gitlab.projects.get(project.id)
            has_sentryclirc, has_dsn = get_sentryclirc(project)
            logging.debug(
                f"project {project.name_with_namespace} "
                f"has_sentryclirc={has_sentryclirc} "
                f"has_dsn={has_dsn}"
            )
            # both sentryclirc and dsn ? we're done here
            if has_sentryclirc and has_dsn:
                logging.info(
                    f"project {project.name_with_namespace} has a sentry project "
                )
                run_stats["has_sentry_dsn"] += 1
                continue

            # sentryclirc but no dsn ? check for pending MR
            elif has_sentryclirc and not has_dsn:
                for mr in mr_by_project[project.id]:
                    if mr.state == "opened":
                        logging.info(
                            f"project {project.name_with_namespace} has a "
                            "pending dsn MR"
                        )
                        run_stats["mr_dsn_waiting"] += 1
                        break
                else:
                    sentry_project_name = "-".join(
                        project.path_with_namespace.split("/")[1:]
                    )
                    logging.info(f"creating sentry project {sentry_project_name}")
                    try:
                        sentry_project = sentry.create_or_get_project(
                            sentry_group_name,
                            sentry_project_name,
                        )
                    except Exception as err:
                        logging.warning(
                            f"project {project.name_with_namespace} failed to "
                            f"get/create its sentry project ({err})"
                        )
                        continue
                    clients_keys = sentry.get_clients_keys(
                        sentry_group_name, sentry_project["slug"]
                    )
                    dsn = clients_keys[0]["dsn"]["public"]
                    # setup ratelimit for key
                    key_id = clients_keys[0]["id"]
                    sentry.set_rate_limit_for_key(sentry_project["slug"], key_id)
                    logging.info(
                        f"project {project.name_with_namespace} sentry dsn: {dsn}"
                    )
                    logging.info(
                        f"project {project.name_with_namespace} needs sentry dsn MR"
                    )
                    add_sentry_dsn_mr(project, dsn, contacts)
                    run_stats["mr_dsn_created"] += 1

            elif not has_sentryclirc:
                for mr in mr_by_project[project.id]:
                    if mr.state == "opened":
                        logging.info(
                            f"project {project.name_with_namespace} has a "
                            "pending sentryclirc MR"
                        )
                        run_stats["mr_sentryclirc_waiting"] += 1
                        break
                    elif mr.state == "closed":
                        logging.info(
                            f"project {project.name_with_namespace} declined "
                            "our sentryclirc MR"
                        )
                        run_stats["mr_sentryclirc_closed"] += 1
                        break
                else:
                    # This is for handling a corner-case where project have been transfered by
                    # recopying the entire repository and existing MR's author have been rewritten
                    # leaving an existing branch that would be updated at every run
                    try:
                        _ = project.branches.get('auto_add_sentry')
                        logging.warning(
                            f"project {project.name_with_namespace} triggered a corner-case "
                            "with existing branch but no 'true' MR"
                        )
                        continue
                    except GitlabGetError:
                        pass

                    logging.info(
                        f"project {project.name_with_namespace} needs sentry "
                        ".sentryclirc MR"
                    )
                    run_stats["mr_sentryclirc_created"] += 1
                    try:
                        propose_sentry_mr(project, contacts)
                    except Exception as err:
                        logging.warning(
                            f"project {project.name_with_namespace} failed to "
                            f"create the .sentryclirc MR ({err})"
                        )

    logging.info(f"run stats: {dict(run_stats)}")


if __name__ == "__main__":
    sentry_sdk.init(
        debug=False,
        dsn="https://7dbff29bc3e049829ba89831c20fa21e@sentry.numberly.net/64",
        environment="production",
    )
    main()
